
function T = Sensor_Data(pipe,colorizer,profile,dev,name, align)
    %This part is already done in revengence.m, it remains in comments for
    %debugging
    % Make Pipeline object to manage streaming
    % Make Colorizer object to prettify depth output
    %pipe = realsense.pipeline();
    %colorizer = realsense.colorizer();
    % Start streaming on an arbitrary camera with default settings
    %profile = pipe.start();
    % Get streaming device's name
    %dev = profile.get_device();
    %name = dev.get_info(realsense.camera_info.name);
    





    %Persistence is for error checking system, ignore it
    persistent count
    if isempty(count)
        count = 1;
        first_trigger = 0;
    end
    
    
    
    %While loop only for debugging
    %while(1)

    fs = pipe.wait_for_frames();
    aligned_frames = align.process(fs);
    






    % Select depth frame
    %depth = fs.get_depth_frame();
    depth_frame = aligned_frames.get_depth_frame();
    
    
    % Colorize depth frame
    depth_color = colorizer.colorize(depth_frame);
    color = fs.get_color_frame();


    % Get actual data and convert into a format imshow can use
    % (Color data arrives as [R, G, B, R, G, B, ...] vector)
    data = color.get_data();
    img = permute(reshape(data',[3,color.get_width(),color.get_height()]),[3 2 1]);
    %figure(3)
    depth_data = depth_color.get_data();
    


    
    depth_img = permute(reshape(depth_data',[3,depth_color.get_width(),depth_color.get_height()]),[3 2 1]);


    %Some wizardry, ignore for now
    %figure(2)
    rgbImage = img;
    [BW, maskedRGBImage] = createMask(rgbImage);
    labeledImage = bwlabel(BW);
    blobMeasurements = regionprops(labeledImage, 'Area', 'Centroid', 'BoundingBox');
    allBlobAreas = [blobMeasurements.Area];
    [~, idx] = max(allBlobAreas);
    centroid = zeros(0, 2);
    %Failed attempts to find function to get the right pixels
    %depth_pixel = depth.project_color_pixel_to_depth_pixel(200 ,232)
    %depth_pixel = depth_image(200, 232)
    
    scalefactor = 795;

    figure(2);
    imshow(maskedRGBImage)
    %imshow(img)
    %figure(2);
    %imshow(depth_img)
    hold on;


    % Check if centoid is empty, if it is it wont do any tracking
    if ~isempty(blobMeasurements(idx))
        centroid = blobMeasurements(idx).Centroid;
        plot(centroid(1), centroid(2), 'r+', 'MarkerSize', 10, 'LineWidth', 2)
        hold off

        %848 x 480  

        
        
        x = int16(centroid(1));
        x=min(x,847);
        y = int16(centroid(2));
        y=min(y,479);
        distance = depth_frame.get_distance(x, y);
        f = 595;
        p_x = 324.7;
        p_y = 248.2;
        x_coord = ((centroid(1) - p_x) * distance)/f;
        y_coord = ((centroid(2) - p_y) * distance)/f;
        % x_end = 0.06*x_coord + 0.213;
        % y_end = 0.24*y_coord - 0.004;
        x_end = 0.233*x_coord + 0.107;
        y_end = 0.8358*y_coord + 0.0125;

        % x_end = x_coord /20
        % y_end = y_coord /
        %plot(centroid(2)/scalefactor-0.4,centroid(1)/795)

        positional = [x_end,y_end,distance - 0.3];

        old_pos = positional;
        first_trigger = 1;
    
        
    %Ignore the below, its just error catching


    %elseif first_trigger == 1
        
    else
        positional = [0.2,0.2,0.2];
    end

    %imshow(BW);
    %imshow(maskedRGBImage);


    
    %end

    %This is the output return value
    T = positional;
end

function [BW,maskedRGBImage] = createMask(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 20-Oct-2023
%------------------------------------------------------


% Convert RGB image to chosen color space
I = RGB;

% Define thresholds for channel 1 based on histogram settings
channel1Min = 163.000;
channel1Max = 255.000;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 95.000;
channel2Max = 209.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.000;
channel3Max = 115.000;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

end


function [BW,maskedRGBImage] = createMaskUS(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 24-Oct-2023
%------------------------------------------------------


% Convert RGB image to chosen color space
I = RGB;

% Define thresholds for channel 1 based on histogram settings
channel1Min = 76.000;
channel1Max = 143.000;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 42.000;
channel2Max = 108.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 8.000;
channel3Max = 47.000;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

end

