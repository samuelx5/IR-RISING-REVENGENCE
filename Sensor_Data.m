
function T = Sensor_Data(pipe,colorizer,profile,dev,name)
    % Make Pipeline object to manage streaming
    %pipe = realsense.pipeline();
    
    % Make Colorizer object to prettify depth output
    %colorizer = realsense.colorizer();
    figure(2)
    % Start streaming on an arbitrary camera with default settings
    %profile = pipe.start();
    %positional = [0.2,0.2,0.2];
    % Get streaming device's name
    %dev = profile.get_device();
    %name = dev.get_info(realsense.camera_info.name);
    %while(1)
    % Get frames. We discard the first couple to    allow
    % the camera time to settle
    %for i = 1:5
    fs = pipe.wait_for_frames();
    %end
    
    % Stop streaming
    %pipe.stop();

    % Select depth frame
    depth = fs.get_depth_frame();
    
    % Colorize depth frame
    %color = colorizer.colorize(depth);
     color = fs.get_color_frame();


    % Get actual data and convert into a format imshow can use
    % (Color data arrives as [R, G, B, R, G, B, ...] vector)
    data = color.get_data();
    img = flip(flip(permute(reshape(data',[3,color.get_width(),color.get_height()]),[3 2 1]),2),1);
   



    % Display image
    %imshow(img);
    %title(sprintf("Colorized depth frame from %s", name));


    
    rgbImage = img;
    [BW, maskedRGBImage] = createMask(rgbImage);
    labeledImage = bwlabel(BW);
    blobMeasurements = regionprops(labeledImage, 'Area', 'Centroid', 'BoundingBox');
    allBlobAreas = [blobMeasurements.Area];
    [~, idx] = max(allBlobAreas);
    centroid = zeros(0, 2);
    
    scalefactor = 795;
    imshow(maskedRGBImage);
    hold on;



    if ~isempty(blobMeasurements(idx))
        centroid = blobMeasurements(idx).Centroid;
        plot(centroid(1), centroid(2), 'r+', 'MarkerSize', 10, 'LineWidth', 2)
        
        %636 x 480  

        positional = [centroid(1),centroid(2)]

        positional = [centroid(2)/scalefactor-0.4,centroid(1)/795, 0.1];
        %plot(centroid(2)/scalefactor-0.4,centroid(1)/795)
        old_pos = positional;
        first_trigger = 1;

    elseif isempty(blobMeasurements(idx)) && first_trigger == 1
        
    else
        positional = [0.2,0.2,0.2]
    end

    %imshow(BW);
    %imshow(maskedRGBImage);


    
    %end
    
    T = transl(positional);
end

function [BW,maskedRGBImage] = createMask(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 20-Oct-2023
%------------------------------------------------------


% Convert RGB image to chosen color space
I = RGB;

% Define thresholds for channel 1 based on histogram settings
channel1Min = 163.000;
channel1Max = 255.000;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 95.000;
channel2Max = 209.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.000;
channel3Max = 115.000;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

end
